我们先总结C++中对于面向对象的概念 看看其他的语言是不是也是这样的

类 和 对象

成员数据 和 成员函数

访问权限

继承 和 派生

不是和想说明了 呢? 



## 多态

编译时多态 通过模板函数 或者说是重载函数 有着不同的参数列表的函数

运行时多态 需要结合虚函数和继承实现 原理其实还是生成了模板函数 需要根据你给的参数的类型进行判断



模板函数是 在编译的时候进行实例化的

函数模板是 在运行的时候进行实例化的



我的理解是 将模板函数理解为泛型 对的

多态是基于继承和虚函数实现的 



以后我们就叫函数模板叫泛型了 

泛型是更加高级的函数重载 不对啊 我们的泛型 其实没有办法解决就是参数列表不相同的问题 其实两个就是理解为互为补充 





## 虚函数

具有关键字`virtual`的成员函数就是虚函数 因为虚函数是需要被继承的 故无法被继承的函数 就无法被声明为虚函数 比如我们的构造函数 和 析构函数

作用 : 通过派生类对虚函数进行重写/重载 实现新的功能 然后利用父类指针就可以调用同名函数 但是具体指向却是不同的

具体场景 : 一家宠物店 需要管理各种小动物

```
// Animal 是基类 可以派生出不同的动物 猫 狗 兔子
void Feed(Animal&pet){
    pet.feed()  // 这里会根据其派生类中对于feed函数的具体实现 执行对应的功能
} 
```



## 纯虚函数

一个基类如果有纯虚函数 它就是抽象类 无法实例化 但是可以有指针

格式是固定的 它没有具体的实现 需要你在其派生类中进行实现

```cpp
class V{
    virtual void feed() =0;
}
```



理解了: 我们的基类不需要被调用 但是为了方便实现 本质上还是虚函数 也就是一个特指





## 静态数据成员

静态 共享 

静态 : 生命周期

共享 : 该类的所有对象 都共用一个静态数据成员

所以你无法在类的实现里对其进行初始化 这就变成了 你每创建一个新的对象 就会其进行赋值 

你需要在类的实现外部 对其进行赋值

## 静态数据函数

相对应的 其只能操作我们的静态数据的函数 就是静态数据函数了 

也就是说 我们的成员函数是



## 函数模板

泛型 让我们的函数 可以接受不同数据类型的变量 返回不同的数据类型  

```cpp
template <typename T>
T add (T a, T b)
{
    return a + b;
}
// 或者你可以写成
template <class T>
T add (T a, T b)
{
    return a + b;
}
```

我们也可以自己指定类型 或者使用固定的类型



## 类模板

同样的 我们可以根据参数类型 创建出特别的对象

```cpp
template <class T>
class Container
{
public:
    Container(T a, T b) : x(a), y(b) {}
    T getX() { return x; }
    T getY() { return y; }
private:
    T x, y;
};
```



## 抽象类

如果我们的类中 存在一个纯虚函数 我们的类就会变成抽象类

抽象类无法实例化,我们需要将其派生然后在派生类中对 虚函数进行实现



## 虚基类

主要是为了解决 菱形继承的问题 

即两个基类 有着相同的父类  这个时候 我们出现了逻辑上的二义性 我们使用虚拟继承避免 

使用了虚继承的类 就被叫做虚基类 

```cpp
class A : virtual public Base 
```







