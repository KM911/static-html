---
title: 设计模式
mathjax: false
date: 2023-03-19 09:56:57
tags:
categories:
---

# 设计模式

前人的经验.

# 单例模式

一个类只能有一个对象/实例.

这里不是说你只在你的程序中只进行一次 new的操作导致只有一个对象,而是通过将对象本身设置为类的属性,强制保证了对象的唯一性.

## 实现方式

* 饿汉式

```java
class Book{
    // 构造函数为private后 就无法通过new去创建对象
    private Book(){}
    private static Book instance = new Book();
    // 我们现在只能通过getInstance这个静态方法获取该对象
    public  static Book getInstance(){
        return instance;
    }
}
```

* 懒汉式 

```java
class Bank{
    private Bank(){}
    private static Bank instance = null;
    public static  Bank getInstance(){
        if (instance == null){
            return instance = new Bank();
        }
        return  instance;
    }
}

```

## 对比分析

* 饿汉式在类被加载时就创建了对象,懒汉式只有调用getInstance方法才会创建.前者会占据内存更多的时间,但是它是并发安全的(你就不该在一个并发的程序里写创建对象这种事情) 
* 其实差别不是很大



# 抽象模板

额,这里其实就是创建一个虚基类,然后继承,重写,指向之类对象的父类指针

因为java中并没有template这样的关键字,我就认为他是在利用抽象类,其实也不对,只是实现方式不太一样.

这里我只先给出一个抽象类继承的例子.

这里的例子中,我们创建了一个虚基类`PayMent`,并继承它创建了一个`Alipay`,我们也可以创建`wechatpay`,我们可以将注意力放到就是具体的支付流程实现上,而不是每一个都需要去重写一次流程,当然了这里其实应该利用基类指针的.

```java
public class abstracttest {
    public static void main(String[] args) {
        Alipay pay = new Alipay();
        pay.PayAction(100);

    }
}
abstract class PayMent{
     public int money;
     public abstract void   CheckMoney();
     public abstract void  Pay(int price);
     public abstract void SaveMoney();

     public void PayAction(int price){
         this.CheckMoney();
         this.Pay(price);
         this.SaveMoney();
     }
}
class Alipay extends PayMent{
    public void CheckMoney(){
        System.out.println("查询支付宝账户余额 访问支付宝的api");
        this.money = 1000;
    }

    public void Pay(int price){
        System.out.println("支付中");
        this.money = this.money - price;
    }
    public void SaveMoney(){
        System.out.println("账户剩余金额为"+this.money);
    }
}
```



愿景 使命 价值观

我们是谁 我们做什么

愿景 : 青年创客

使命 :  

价值观 : 组织能力 协作能力 愿不愿 能不能 许不许 

团队合作 拥抱变化  

做事 此时此刻 非你莫属    

凡事有交代 件件有着落

今天比明天好

人生没有捷径 

遇到我是你的运气,遇到你是我的福气

